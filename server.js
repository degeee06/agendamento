import express from "express";
import cors from "cors";
import { createClient } from "@supabase/supabase-js";
import { GoogleSpreadsheet } from "google-spreadsheet";

const PORT = process.env.PORT || 3000;
const app = express();

// ==================== CORS CONFIGURADO CORRETAMENTE ====================
app.use(cors({
  origin: [
    'https://frontrender-iota.vercel.app',
    'https://frontrender.netlify.app',
    'http://localhost:3000',
    'http://localhost:5173',
    'https://localhost:3000'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin',
    'Access-Control-Allow-Headers'
  ],
  exposedHeaders: ['Content-Length', 'Authorization'],
  preflightContinue: false,
  optionsSuccessStatus: 204,
  maxAge: 86400 // 24 hours
}));

app.options('*', cors());
app.use(express.json());

// ==================== SISTEMA DE CACHE INTELIGENTE ====================
const cache = new Map();
const pendingActions = new Map();

const cacheManager = {
  set(key, value, ttl = 2 * 60 * 1000) {
    cache.set(key, {
      value,
      expiry: Date.now() + ttl,
      timestamp: Date.now()
    });
  },

  get(key) {
    const item = cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      cache.delete(key);
      return null;
    }
    
    return item.value;
  },

  async getOrSet(key, fetchFn, ttl = 2 * 60 * 1000) {
    const cached = this.get(key);
    if (cached) {
      console.log('üì¶ Cache hit:', key);
      return cached;
    }

    console.log('üîÑ Cache miss:', key);
    const value = await fetchFn();
    this.set(key, value, ttl);
    return value;
  },

  delete(key) {
    console.log('üóëÔ∏è Cache deleted:', key);
    return cache.delete(key);
  },

  deletePattern(pattern) {
    let deletedCount = 0;
    for (const key of cache.keys()) {
      if (key.includes(pattern)) {
        cache.delete(key);
        deletedCount++;
      }
    }
    console.log(`üóëÔ∏è Cache pattern deleted: ${pattern} (${deletedCount} items)`);
    return deletedCount;
  },

  clear() {
    cache.clear();
  }
};

// ==================== SISTEMA OFFLINE + A√á√ïES PENDENTES ====================
const offlineManager = {
  addAction(userEmail, action) {
    if (!pendingActions.has(userEmail)) {
      pendingActions.set(userEmail, []);
    }
    
    const actionWithId = {
      id: `pending_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      ...action,
      retryCount: 0
    };
    
    const userQueue = pendingActions.get(userEmail);
    userQueue.push(actionWithId);
    
    console.log(`üìù Action queued for ${userEmail}:`, action.type, actionWithId.id);
    return actionWithId.id;
  },

  getActions(userEmail) {
    return pendingActions.get(userEmail) || [];
  },

  removeAction(userEmail, actionId) {
    const userQueue = pendingActions.get(userEmail);
    if (userQueue) {
      const filteredQueue = userQueue.filter(action => action.id !== actionId);
      pendingActions.set(userEmail, filteredQueue);
    }
  },

  async retryPendingActions(userEmail) {
    const userQueue = this.getActions(userEmail);
    if (userQueue.length === 0) return [];

    console.log(`üîÑ Retrying ${userQueue.length} pending actions for ${userEmail}`);
    
    const results = [];
    for (const action of userQueue) {
      try {
        let result;
        switch (action.type) {
          case 'CREATE_AGENDAMENTO':
            result = await handleAgendar(action.data, userEmail, true);
            break;
          case 'UPDATE_AGENDAMENTO':
            result = await handleAtualizarAgendamento(action.agendamentoId, action.data, userEmail, true);
            break;
          case 'DELETE_AGENDAMENTO':
            result = await handleCancelarAgendamento(action.agendamentoId, userEmail, true);
            break;
        }
        
        if (result.success) {
          this.removeAction(userEmail, action.id);
          results.push({ actionId: action.id, success: true });
        }
      } catch (error) {
        console.error(`‚ùå Error retrying action ${action.id}:`, error.message);
        results.push({ actionId: action.id, success: false, error: error.message });
      }
    }
    
    return results;
  }
};

// ==================== CONFIGURA√á√ÉO SUPABASE ====================
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// ==================== SUPABASE REALTIME PARA CACHE AUTOM√ÅTICO ====================
function setupSupabaseRealtime() {
  try {
    const subscription = supabase
      .channel('agendamentos-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'agendamentos'
        },
        (payload) => {
          console.log('üîî Realtime update received:', payload.eventType);
          
          // Invalida cache baseado no email do usu√°rio afetado
          if (payload.new?.email) {
            const userEmail = payload.new.email;
            cacheManager.deletePattern(`agendamentos_${userEmail}`);
            cacheManager.deletePattern(`estatisticas_${userEmail}`);
            cacheManager.deletePattern(`sugestoes_${userEmail}`);
          } else if (payload.old?.email) {
            const userEmail = payload.old.email;
            cacheManager.deletePattern(`agendamentos_${userEmail}`);
            cacheManager.deletePattern(`estatisticas_${userEmail}`);
            cacheManager.deletePattern(`sugestoes_${userEmail}`);
          }
          
          // Invalida cache global se necess√°rio
          if (payload.eventType === 'INSERT' || payload.eventType === 'DELETE') {
            cacheManager.deletePattern('sugestoes_');
            cacheManager.deletePattern('estatisticas_');
          }
        }
      )
      .subscribe();

    console.log('‚úÖ Supabase Realtime connected for cache invalidation');
  } catch (error) {
    console.error('‚ùå Failed to setup Supabase Realtime:', error.message);
  }
}

// Inicializar Realtime
setupSupabaseRealtime();

// ==================== CONFIGURA√á√ÉO DEEPSEEK IA ====================
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;
const DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions";

const MODELOS_IA = {
  PADRAO: "deepseek-chat",
  RACIOCINIO: "deepseek-reasoner",
  ECONOMICO: "deepseek-chat"
};

async function chamarDeepSeekIA(mensagem, contexto = "", tipo = "PADRAO") {
  try {
    if (!DEEPSEEK_API_KEY) {
      throw new Error("Chave da API DeepSeek n√£o configurada");
    }

    const modelo = MODELOS_IA[tipo] || MODELOS_IA.PADRAO;
    const prompt = contexto ? `${contexto}\n\nPergunta do usu√°rio: ${mensagem}` : mensagem;

    const response = await fetch(DEEPSEEK_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify({
        model: modelo,
        messages: [
          {
            role: "system",
            content: contexto || "Voc√™ √© um assistente de agenda inteligente. Ajude os usu√°rios a gerenciarem seus compromissos de forma eficiente. Seja √∫til, amig√°vel e direto ao ponto."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 1000,
        temperature: 0.7
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro na API DeepSeek: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  } catch (error) {
    console.error("Erro ao chamar DeepSeek IA:", error);
    throw error;
  }
}

// ==================== FUN√á√ïES IA (MANTIDAS ORIGINAIS) ====================
async function analisarDescricaoNatural(descricao, userEmail) {
  try {
    const hoje = new Date();
    const amanha = new Date(hoje);
    amanha.setDate(amanha.getDate() + 1);

    function calcularDataValida(data) {
      const dataObj = new Date(data);
      return dataObj.toISOString().split('T')[0];
    }

    const prompt = `
Analise a seguinte descri√ß√£o de agendamento e extraia as informa√ß√µes no formato JSON:

DESCRI√á√ÉO: "${descricao}"

USU√ÅRIO: ${userEmail}
DATA ATUAL: ${hoje.toISOString().split('T')[0]}

Extraia as seguintes informa√ß√µes:
- nome (string): Nome da pessoa ou evento
- data (string no formato YYYY-MM-DD): Data do compromisso
- horario (string no formato HH:MM): Hor√°rio do compromisso
- descricao (string): Descri√ß√£o detalhada do compromisso

üîî REGRAS IMPORTANTES:
- Se n√£o mencionar data espec√≠fica, use "${calcularDataValida(amanha.toISOString().split('T')[0])}"
- Se n√£o mencionar hor√°rio, use "09:00" (hor√°rio padr√£o)
- Para datas relativas: "hoje" = data atual, "amanh√£" = data atual + 1 dia
- Para dias da semana: converta para a pr√≥xima ocorr√™ncia
- ‚úÖ DOMINGOS S√ÉO PERMITIDOS: Agende normalmente para domingos
- Use o ano atual para todas as datas

Exemplo de resposta:
{"nome": "Reuni√£o com Jo√£o", "data": "2024-01-14", "horario": "14:00", "descricao": "Reuni√£o dominical"}

Responda APENAS com o JSON v√°lido, sem nenhum texto adicional.
`;

    const resposta = await chamarDeepSeekIA(prompt, "", "RACIOCINIO");
    
    const jsonMatch = resposta.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const dados = JSON.parse(jsonMatch[0]);
      console.log('‚úÖ Agendamento processado (domingos permitidos):', dados.data);
      return dados;
    }
    
    throw new Error("N√£o foi poss√≠vel extrair dados estruturados da descri√ß√£o");
  } catch (error) {
    console.error("Erro ao analisar descri√ß√£o natural:", error);
    throw error;
  }
}

async function analisarEstatisticasPessoais(agendamentos, userEmail) {
  try {
    const estatisticas = {
      total: agendamentos.length,
      este_mes: agendamentos.filter(a => {
        const dataAgendamento = new Date(a.data);
        const agora = new Date();
        return dataAgendamento.getMonth() === agora.getMonth() && 
               dataAgendamento.getFullYear() === agora.getFullYear();
      }).length,
      confirmados: agendamentos.filter(a => a.status === 'confirmado').length,
      pendentes: agendamentos.filter(a => a.status === 'pendente').length,
      cancelados: agendamentos.filter(a => a.status === 'cancelado').length,
      via_ia: agendamentos.filter(a => a.criado_via_ia).length
    };

    const contexto = `
Estat√≠sticas dos agendamentos do usu√°rio ${userEmail}:

- Total de agendamentos: ${estatisticas.total}
- Agendamentos este m√™s: ${estatisticas.este_mes}
- Confirmados: ${estatisticas.confirmados}
- Pendentes: ${estatisticas.pendentes}
- Cancelados: ${estatisticas.cancelados}
- Criados via IA: ${estatisticas.via_ia}

Forne√ßa uma an√°lise inteligente sobre:
1. Comportamento de agendamento do usu√°rio
2. Taxa de comparecimento (confirmados vs total)
3. Distribui√ß√£o ao longo do tempo
4. Recomenda√ß√µes personalizadas

Seja encorajador e pr√°tico. M√°ximo de 200 palavras.
`;

    const analise = await chamarDeepSeekIA("Analise essas estat√≠sticas de agendamentos:", contexto);
    
    return {
      estatisticas,
      analise_ia: analise
    };
  } catch (error) {
    console.error("Erro ao analisar estat√≠sticas:", error);
    throw error;
  }
}

// ==================== CONFIGURA√á√ÉO GOOGLE SHEETS ====================
let creds;
try {
  creds = JSON.parse(process.env.GOOGLE_SERVICE_ACCOUNT);
} catch (e) {
  console.error("Erro ao parsear GOOGLE_SERVICE_ACCOUNT:", e);
  process.exit(1);
}

async function accessUserSpreadsheet(userEmail, userMetadata) {
  try {
    const spreadsheetId = userMetadata?.spreadsheet_id;
    
    if (!spreadsheetId) {
      console.log(`üìù Usu√°rio ${userEmail} n√£o configurou Sheets`);
      return null;
    }
    
    const doc = new GoogleSpreadsheet(spreadsheetId);
    await doc.useServiceAccountAuth(creds);
    await doc.loadInfo();
    
    console.log(`‚úÖ Acessando planilha do usu√°rio: ${userEmail}`);
    return doc;
  } catch (error) {
    console.error(`‚ùå Erro ao acessar planilha do usu√°rio ${userEmail}:`, error.message);
    return null;
  }
}

async function createSpreadsheetForUser(userEmail, userName) {
  try {
    console.log('üîß Iniciando cria√ß√£o de planilha para:', userEmail);
    
    const doc = new GoogleSpreadsheet();
    await doc.useServiceAccountAuth(creds);
    
    await doc.createNewSpreadsheetDocument({
      title: `Agendamentos - ${userName || userEmail}`.substring(0, 100),
    });
    
    console.log('üìä Planilha criada, ID:', doc.spreadsheetId);
    
    const sheet = doc.sheetsByIndex[0];
    await sheet.setHeaderRow([
      'id', 'nome', 'email', 'telefone', 'data', 'horario', 'status', 'confirmado', 'criado_em', 'criado_via_ia', 'descricao'
    ]);
    
    try {
      await doc.shareWithEmail(userEmail, {
        role: 'writer',
        emailMessage: 'Planilha de agendamentos compartilhada com voc√™!'
      });
      console.log('‚úÖ Planilha compartilhada com:', userEmail);
    } catch (shareError) {
      console.warn('‚ö†Ô∏è N√£o foi poss√≠vel compartilhar a planilha:', shareError.message);
    }
    
    console.log(`üìä Nova planilha criada para ${userEmail}: ${doc.spreadsheetId}`);
    return doc.spreadsheetId;
    
  } catch (error) {
    console.error("‚ùå Erro ao criar planilha:", error);
    throw new Error(`Falha ao criar planilha: ${error.message}`);
  }
}

// ==================== MIDDLEWARE AUTH ====================
async function authMiddleware(req, res, next) {
  const token = req.headers["authorization"]?.split("Bearer ")[1];
  if (!token) return res.status(401).json({ msg: "Token n√£o enviado" });

  const { data, error } = await supabase.auth.getUser(token);
  if (error || !data.user) return res.status(401).json({ msg: "Token inv√°lido" });

  req.user = data.user;
  next();
}

// ==================== HANDLERS COM CACHE INTELIGENTE ====================
async function handleAgendar(dados, userEmail, isRetry = false) {
  try {
    // 1Ô∏è‚É£ Backup no Google Sheets primeiro
    const userMetadata = (await supabase.auth.admin.getUserById(req.user.id)).data.user?.user_metadata;
    const doc = await accessUserSpreadsheet(userEmail, userMetadata);
    
    if (doc) {
      const sheet = doc.sheetsByIndex[0];
      await sheet.addRow({
        ...dados,
        id: `temp_${Date.now()}`,
        email: userEmail,
        criado_em: new Date().toISOString(),
        status: 'pendente'
      });
    }

    // 2Ô∏è‚É£ Insert no Supabase
    const { data, error } = await supabase
      .from("agendamentos")
      .insert([{ ...dados, email: userEmail }])
      .select()
      .single();

    if (error) throw error;

    // 3Ô∏è‚É£ Invalidar cache
    cacheManager.deletePattern(`agendamentos_${userEmail}`);
    cacheManager.deletePattern(`estatisticas_${userEmail}`);
    cacheManager.deletePattern(`sugestoes_${userEmail}`);

    console.log('‚úÖ Agendamento criado com cache invalidation');

    return { success: true, data };

  } catch (error) {
    console.error('‚ùå Erro ao agendar:', error);
    
    if (!isRetry) {
      // Adiciona √† fila de a√ß√µes pendentes
      offlineManager.addAction(userEmail, {
        type: 'CREATE_AGENDAMENTO',
        data: dados
      });
      console.log('üìù Agendamento adicionado √† fila offline');
    }
    
    return { success: false, error: error.message };
  }
}

async function handleAtualizarAgendamento(agendamentoId, dados, userEmail, isRetry = false) {
  try {
    // 1Ô∏è‚É£ Atualizar no Supabase
    const { data, error } = await supabase
      .from("agendamentos")
      .update(dados)
      .eq("id", agendamentoId)
      .eq("email", userEmail)
      .select()
      .single();

    if (error) throw error;

    // 2Ô∏è‚É£ Invalidar cache
    cacheManager.deletePattern(`agendamentos_${userEmail}`);
    cacheManager.deletePattern(`estatisticas_${userEmail}`);
    cacheManager.deletePattern(`sugestoes_${userEmail}`);

    console.log('‚úÖ Agendamento atualizado com cache invalidation');

    return { success: true, data };

  } catch (error) {
    console.error('‚ùå Erro ao atualizar agendamento:', error);
    
    if (!isRetry) {
      offlineManager.addAction(userEmail, {
        type: 'UPDATE_AGENDAMENTO',
        agendamentoId,
        data: dados
      });
    }
    
    return { success: false, error: error.message };
  }
}

async function handleCancelarAgendamento(agendamentoId, userEmail, isRetry = false) {
  try {
    // 1Ô∏è‚É£ Buscar dados antes de deletar para backup
    const { data: agendamento } = await supabase
      .from("agendamentos")
      .select("*")
      .eq("id", agendamentoId)
      .eq("email", userEmail)
      .single();

    // 2Ô∏è‚É£ Backup no Sheets antes de deletar
    if (agendamento) {
      const userMetadata = (await supabase.auth.admin.getUserById(req.user.id)).data.user?.user_metadata;
      const doc = await accessUserSpreadsheet(userEmail, userMetadata);
      
      if (doc) {
        const sheet = doc.sheetsByIndex[0];
        await sheet.addRow({
          ...agendamento,
          status: 'cancelado',
          canceled_at: new Date().toISOString()
        });
      }
    }

    // 3Ô∏è‚É£ Delete do Supabase
    const { error } = await supabase
      .from("agendamentos")
      .delete()
      .eq("id", agendamentoId)
      .eq("email", userEmail);

    if (error) throw error;

    // 4Ô∏è‚É£ Invalidar cache
    cacheManager.deletePattern(`agendamentos_${userEmail}`);
    cacheManager.deletePattern(`estatisticas_${userEmail}`);
    cacheManager.deletePattern(`sugestoes_${userEmail}`);

    console.log('‚úÖ Agendamento cancelado com cache invalidation');

    return { success: true };

  } catch (error) {
    console.error('‚ùå Erro ao cancelar agendamento:', error);
    
    if (!isRetry) {
      offlineManager.addAction(userEmail, {
        type: 'DELETE_AGENDAMENTO',
        agendamentoId
      });
    }
    
    return { success: false, error: error.message };
  }
}

// ==================== ROTAS ATUALIZADAS COM CACHE ====================

// üî• HEALTH CHECKS
app.get("/health", (req, res) => {
  res.json({ 
    status: "OK", 
    message: "Backend rodando com CACHE INTELIGENTE",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    cache_size: cache.size,
    pending_actions: pendingActions.size
  });
});

app.get("/warmup", async (req, res) => {
  try {
    const { data, error } = await supabase.from('agendamentos').select('count').limit(1);
    
    res.json({ 
      status: "WARM", 
      timestamp: new Date().toISOString(),
      supabase: error ? "offline" : "online",
      cache: "active"
    });
  } catch (error) {
    res.json({ 
      status: "COLD", 
      timestamp: new Date().toISOString(),
      error: error.message 
    });
  }
});

// üî• LISTAR AGENDAMENTOS COM CACHE H√çBRIDO
app.get("/agendamentos", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const cacheKey = `agendamentos_${userEmail}`;
    
    const agendamentos = await cacheManager.getOrSet(cacheKey, async () => {
      console.log('üîÑ Buscando agendamentos do DB para:', userEmail);
      const { data, error } = await supabase
        .from("agendamentos")
        .select("*")
        .eq("email", userEmail)
        .order("data", { ascending: true })
        .order("horario", { ascending: true });

      if (error) throw error;
      return data;
    }, 2 * 60 * 1000); // 2 minutos cache

    res.json({ agendamentos });
  } catch (err) {
    console.error("Erro ao listar agendamentos:", err);
    res.status(500).json({ msg: "Erro interno" });
  }
});

// üî• CRIAR AGENDAMENTO COM ATUALIZA√á√ÉO OTIMISTA
app.post("/agendamentos", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const dados = req.body;

    const resultado = await handleAgendar(dados, userEmail);

    if (resultado.success) {
      res.json({ 
        success: true, 
        agendamento: resultado.data,
        pending: offlineManager.getActions(userEmail).length > 0
      });
    } else {
      res.status(500).json({ 
        success: false, 
        msg: "Erro ao criar agendamento",
        pending: true // Indica que foi para fila offline
      });
    }
  } catch (err) {
    console.error("Erro ao criar agendamento:", err);
    res.status(500).json({ msg: "Erro interno" });
  }
});

// üî• ATUALIZAR AGENDAMENTO COM SYNC EM BACKGROUND
app.put("/agendamentos/:id", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const agendamentoId = req.params.id;
    const dados = req.body;

    const resultado = await handleAtualizarAgendamento(agendamentoId, dados, userEmail);

    if (resultado.success) {
      res.json({ 
        success: true, 
        agendamento: resultado.data 
      });
    } else {
      res.status(500).json({ 
        success: false, 
        msg: "Erro ao atualizar agendamento",
        pending: true
      });
    }
  } catch (err) {
    console.error("Erro ao atualizar agendamento:", err);
    res.status(500).json({ msg: "Erro interno" });
  }
});

// üî• CANCELAR AGENDAMENTO COM DELETE OTIMISTA
app.delete("/agendamentos/:id", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const agendamentoId = req.params.id;

    const resultado = await handleCancelarAgendamento(agendamentoId, userEmail);

    if (resultado.success) {
      res.json({ 
        success: true, 
        msg: "Agendamento cancelado com sucesso" 
      });
    } else {
      res.status(500).json({ 
        success: false, 
        msg: "Erro ao cancelar agendamento",
        pending: true
      });
    }
  } catch (err) {
    console.error("Erro ao cancelar agendamento:", err);
    res.status(500).json({ msg: "Erro interno" });
  }
});

// üî• OFFLINE SYNC - RETRY PENDING ACTIONS
app.post("/offline/sync", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    
    const results = await offlineManager.retryPendingActions(userEmail);
    
    res.json({
      success: true,
      results,
      pending_remaining: offlineManager.getActions(userEmail).length
    });
  } catch (error) {
    console.error("Erro no sync offline:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao sincronizar a√ß√µes pendentes" 
    });
  }
});

// üî• CHECK PENDING ACTIONS
app.get("/offline/pending", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const pending = offlineManager.getActions(userEmail);
    
    res.json({
      success: true,
      pending_actions: pending,
      count: pending.length
    });
  } catch (error) {
    console.error("Erro ao verificar a√ß√µes pendentes:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao verificar a√ß√µes pendentes" 
    });
  }
});

// ==================== ROTAS IA (MANTIDAS ORIGINAIS COM CACHE) ====================

app.post("/api/assistente-ia", authMiddleware, async (req, res) => {
  try {
    const { mensagem } = req.body;
    const userEmail = req.user.email;

    if (!mensagem) {
      return res.status(400).json({ success: false, msg: "Mensagem √© obrigat√≥ria" });
    }

    const { data: agendamentos, error } = await supabase
      .from("agendamentos")
      .select("*")
      .eq("email", userEmail)
      .order("data", { ascending: false })
      .limit(5);

    if (error) throw error;

    const contexto = agendamentos && agendamentos.length > 0 
      ? `Aqui est√£o os √∫ltimos agendamentos do usu√°rio para contexto:\n${agendamentos.map(a => `- ${a.data} ${a.horario}: ${a.nome} (${a.status})`).join('\n')}`
      : "O usu√°rio ainda n√£o tem agendamentos.";

    const resposta = await chamarDeepSeekIA(mensagem, contexto, "ECONOMICO");

    res.json({
      success: true,
      resposta,
      agendamentos_referenciados: agendamentos?.length || 0
    });

  } catch (error) {
    console.error("Erro no assistente IA:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao processar pergunta com IA",
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// üî• SUGERIR HOR√ÅRIOS COM CACHE
app.get("/api/sugerir-horarios", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const cacheKey = `sugerir_horarios_${userEmail}`;

    const sugestoes = await cacheManager.getOrSet(cacheKey, async () => {
      const { data: agendamentos, error } = await supabase
        .from("agendamentos")
        .select("*")
        .eq("email", userEmail)
        .gte("data", new Date().toISOString().split('T')[0])
        .order("data", { ascending: true })
        .order("horario", { ascending: true });

      if (error) throw error;

      // Sua l√≥gica original de an√°lise de hor√°rios
      const contexto = `
AN√ÅLISE DE AGENDA - SUGERIR HOR√ÅRIOS LIVRES
Dados da agenda do usu√°rio ${userEmail}:
AGENDAMENTOS EXISTENTES:
${agendamentos.length > 0 ? 
  agendamentos.map(a => `- ${a.data} ${a.horario}: ${a.nome}`).join('\n') 
  : 'Nenhum agendamento futuro encontrado.'
}
DATA ATUAL: ${new Date().toISOString().split('T')[0]}
`;

      return await chamarDeepSeekIA("Analise esta agenda e sugira os melhores hor√°rios livres:", contexto, "ECONOMICO");
    }, 10 * 60 * 1000); // 10 minutos cache

    res.json({
      success: true,
      sugestoes: sugestoes,
      total_agendamentos: 0 // Pode ajustar conforme necess√°rio
    });

  } catch (error) {
    console.error("Erro ao sugerir hor√°rios:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao analisar hor√°rios livres" 
    });
  }
});

// üî• ESTAT√çSTICAS COM CACHE
app.get("/api/estatisticas-pessoais", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const cacheKey = `estatisticas_${userEmail}`;

    const resultado = await cacheManager.getOrSet(cacheKey, async () => {
      const { data: agendamentos, error } = await supabase
        .from("agendamentos")
        .select("*")
        .eq("email", userEmail);

      if (error) throw error;
      return await analisarEstatisticasPessoais(agendamentos || [], userEmail);
    }, 5 * 60 * 1000); // 5 minutos cache

    res.json({
      success: true,
      ...resultado
    });

  } catch (error) {
    console.error("Erro nas estat√≠sticas pessoais:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao gerar estat√≠sticas pessoais" 
    });
  }
});

// üî• SUGEST√ïES INTELIGENTES COM CACHE  
app.get("/api/sugestoes-inteligentes", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const cacheKey = `sugestoes_${userEmail}`;

    const resultado = await cacheManager.getOrSet(cacheKey, async () => {
      const { data: agendamentos, error } = await supabase
        .from("agendamentos")
        .select("*")
        .eq("email", userEmail)
        .order("data", { ascending: true });

      if (error) throw error;

      if (!agendamentos || agendamentos.length === 0) {
        return {
          sugestoes: "üìù Voc√™ ainda n√£o tem agendamentos. Que tal agendar seu primeiro compromisso? Use o agendamento por IA para facilitar!",
          total_agendamentos: 0
        };
      }

      // Sua l√≥gica original para gerar sugest√µes
      const contexto = `
Agendamentos do usu√°rio ${userEmail}:
${agendamentos.map(a => `- ${a.data} ${a.horario}: ${a.nome} (${a.status})`).join('\n')}

Forne√ßa sugest√µes inteligentes baseadas nos padr√µes de agendamento.
`;

      const sugestoes = await chamarDeepSeekIA("Analise esses agendamentos e forne√ßa sugest√µes √∫teis:", contexto, "ECONOMICO");

      return {
        sugestoes,
        total_agendamentos: agendamentos.length
      };
    }, 10 * 60 * 1000); // 10 minutos cache

    res.json({
      success: true,
      ...resultado
    });

  } catch (error) {
    console.error("Erro nas sugest√µes inteligentes:", error);
    res.status(500).json({ 
      success: false, 
      msg: "Erro ao gerar sugest√µes inteligentes" 
    });
  }
});

// ==================== CONFIGURA√á√ÉO SHEETS (MANTIDA ORIGINAL) ====================

app.get("/configuracao-sheets", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const cacheKey = `config_${userEmail}`;
    
    const config = await cacheManager.getOrSet(cacheKey, async () => {
      return {
        temSheetsConfigurado: !!req.user.user_metadata?.spreadsheet_id,
        spreadsheetId: req.user.user_metadata?.spreadsheet_id
      };
    }, 5 * 60 * 1000);
    
    console.log(`üìä Configura√ß√£o do usu√°rio ${userEmail}:`, config);
    res.json(config);
    
  } catch (err) {
    console.error("Erro ao buscar configura√ß√£o:", err);
    res.status(500).json({ msg: "Erro interno" });
  }
});

app.post("/configurar-sheets", authMiddleware, async (req, res) => {
  try {
    const userEmail = req.user.email;
    const { userName } = req.body;

    const spreadsheetId = await createSpreadsheetForUser(userEmail, userName);

    const { error } = await supabase.auth.admin.updateUserById(
      req.user.id,
      { user_metadata: { spreadsheet_id: spreadsheetId } }
    );

    if (error) throw error;

    // Invalidar cache de configura√ß√£o
    cacheManager.delete(`config_${userEmail}`);

    res.json({ 
      success: true, 
      spreadsheetId,
      msg: "Planilha configurada com sucesso!" 
    });

  } catch (err) {
    console.error("Erro ao configurar sheets:", err);
    res.status(500).json({ msg: err.message });
  }
});

// ==================== INICIALIZAR SERVER ====================

app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`üì¶ Cache inteligente: ATIVO`);
  console.log(`üîî Supabase Realtime: CONECTADO`);
  console.log(`üì± Sistema offline: PRONTO`);
  console.log(`ü§ñ IA DeepSeek: ${DEEPSEEK_API_KEY ? 'CONFIGURADA' : 'N√ÉO CONFIGURADA'}`);
});

